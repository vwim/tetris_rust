use block::*;
use tetromino::*;

pub const BOARD_WIDTH: usize = 10;
pub const BOARD_HEIGHT: usize = 20;

#[derive(Copy, Clone, Debug)]
pub struct Board {
	board: [[Option<Color>; BOARD_WIDTH]; BOARD_HEIGHT]
}

impl Board {
	pub fn new() -> Board {
		Board {
			board: [[None; BOARD_WIDTH]; BOARD_HEIGHT]
		}
	}

	pub fn board(&self) -> &[[Option<Color>; BOARD_WIDTH]; BOARD_HEIGHT] {
		&self.board
	}

	pub fn overlap(&self, block: &Block) -> bool {
		let (px, py) = block.position();
		block.rotation().into_iter().any(|&(bx, by)| {
			let (x, y) = (px as isize + bx, py as isize + by);
			if x >= 0 && x < BOARD_WIDTH as isize && y >= 0 && y < BOARD_HEIGHT as isize {
				self.board[y as usize][x as usize].is_some()
			} else {
				true
			}
		})
	}

	pub fn merge(&mut self, block: &Block) {
		let (px, py) = block.position();
		for &(bx, by) in block.rotation().into_iter() {
			let (x, y) = (px as isize + bx, py as isize + by);
			self.board[y as usize][x as usize] = Some(block.color());
		}
	}

	pub fn check_lines(&self) -> Vec<usize> { 
		self.board.iter().enumerate().rev()
					.fold(Vec::new(), |mut acc, (n, x)| {
						if x.iter().all(|&xx| xx.is_some()) {
							acc.push(n);
						}
						acc
					})
	}

	pub fn remove_lines(&mut self, lines: &[usize]) {
		let mut new_board = [[None; BOARD_WIDTH]; BOARD_HEIGHT];
		for ((_, l), nl) in self.board.iter().enumerate()
						.rev()
						.filter(|&(n, _)| !lines.iter().position(|&x| x == n).is_some())
						.zip(new_board.iter_mut().rev()) {
			*nl = *l;
		}
		self.board = new_board
	}
}